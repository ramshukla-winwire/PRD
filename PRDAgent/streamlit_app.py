import streamlit as st
import asyncio
import json
import os
import io
from datetime import datetime
from typing import Dict, Any, Optional
from docx import Document
from docx.shared import Inches, Pt
from docx.enum.text import WD_ALIGN_PARAGRAPH
from prd_agent import get_groq_agent, PRDResult
from utils.template_manager import get_template_manager
from utils.prd_evaluator import PRDEvaluator

# Page configuration
st.set_page_config(
    page_title="BRD Generator - Powered by Groq",
    page_icon="üìã",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS for better styling
st.markdown("""
<style>
    .main-header {
        text-align: center;
        padding: 2rem 0;
        background: linear-gradient(90deg, #1e40af 0%, #7c3aed 100%);
        color: white;
        margin: -1rem -1rem 2rem -1rem;
        border-radius: 10px;
    }
    
    .powered-by {
        text-align: center;
        margin-top: 2rem;
        color: #666;
        font-style: italic;
    }
    
    .brand {
        color: #f39c12;
        font-weight: bold;
    }
    
    .feature-card {
        background: white;
        padding: 1.5rem;
        border-radius: 10px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        margin: 1rem 0;
        border-left: 4px solid #7c3aed;
    }
    
    .metric-card {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 1rem;
        border-radius: 8px;
        text-align: center;
        margin: 0.5rem 0;
    }
    
    .success-message {
        background: #d4edda;
        color: #155724;
        padding: 1rem;
        border-radius: 5px;
        border-left: 4px solid #28a745;
        margin: 1rem 0;
    }
    
    .warning-message {
        background: #fff3cd;
        color: #856404;
        padding: 1rem;
        border-radius: 5px;
        border-left: 4px solid #ffc107;
        margin: 1rem 0;
    }
</style>
""", unsafe_allow_html=True)

# Initialize session state
if 'groq_agent' not in st.session_state:
    try:
        st.session_state.groq_agent = get_groq_agent()
    except Exception as e:
        st.error(f"Failed to initialize Groq agent: {e}")
        st.info("Please set your GROQ_API_KEY environment variable and restart the app.")
        st.stop()

if 'template_manager' not in st.session_state:
    st.session_state.template_manager = get_template_manager()

if 'session_id' not in st.session_state:
    st.session_state.session_id = None

if 'generated_prd' not in st.session_state:
    st.session_state.generated_prd = None

def markdown_to_docx(markdown_content: str, title: str = "Business Requirements Document") -> io.BytesIO:
    """Convert markdown content to a professionally formatted DOCX document"""
    try:
        doc = Document()
        
        # Set document properties
        doc.core_properties.title = title
        doc.core_properties.author = "BRD Generator - Powered by Groq"
        doc.core_properties.comments = "Generated by Groq BRD Generator using CIRCLES Framework"
        
        # Add title page
        title_para = doc.add_heading(title, 0)
        title_para.alignment = WD_ALIGN_PARAGRAPH.CENTER
        
        # Add generation timestamp
        timestamp_para = doc.add_paragraph(f"Generated on: {datetime.now().strftime('%B %d, %Y at %I:%M %p')}")
        timestamp_para.alignment = WD_ALIGN_PARAGRAPH.CENTER
        for run in timestamp_para.runs:
            run.font.size = Pt(12)
        
        # Add branding
        branding_para = doc.add_paragraph("Powered by Groq Lightning-Fast AI")
        branding_para.alignment = WD_ALIGN_PARAGRAPH.CENTER
        for run in branding_para.runs:
            run.font.size = Pt(10)
            run.font.italic = True
        
        # Add page break
        doc.add_page_break()
        
        # Clean the markdown content first
        cleaned_content = _clean_markdown_content(markdown_content)
        
        # Process markdown content line by line
        lines = cleaned_content.split('\n')  # Fixed: use \n not \\n
        current_para = None
        in_table = False
        table_rows = []
        in_code_block = False
        in_blockquote = False
        
        i = 0
        while i < len(lines):
            line = lines[i]
            original_line = line
            line = line.strip()
            
            # Skip empty lines when not in special blocks
            if not line and not in_table and not in_blockquote:
                if current_para:
                    current_para = None
                i += 1
                continue
            
            # Handle code blocks
            if line.startswith('```'):
                in_code_block = not in_code_block
                i += 1
                continue
            elif in_code_block:
                # Add code content with monospace font
                para = doc.add_paragraph()
                run = para.add_run(original_line)
                run.font.name = 'Courier New'
                run.font.size = Pt(9)
                i += 1
                continue
            
            # Handle headers with better formatting
            if line.startswith('#'):
                level = len(line) - len(line.lstrip('#'))
                text = line.lstrip('#').strip()
                
                # Clean header text
                text = _clean_text_for_word(text)
                
                if level <= 3:
                    heading = doc.add_heading(text, level)
                    # Add proper spacing
                    if level == 1:
                        heading.paragraph_format.space_before = Pt(18)
                        heading.paragraph_format.space_after = Pt(12)
                    elif level == 2:
                        heading.paragraph_format.space_before = Pt(12)
                        heading.paragraph_format.space_after = Pt(6)
                    else:
                        heading.paragraph_format.space_before = Pt(6)
                        heading.paragraph_format.space_after = Pt(3)
                else:
                    para = doc.add_paragraph()
                    run = para.add_run(text)
                    run.bold = True
                    run.font.size = Pt(12)
            
            # Handle horizontal rules
            elif line.startswith('---') and len(line.strip()) <= 5:
                # Add a horizontal line using a paragraph with bottom border
                para = doc.add_paragraph()
                para.paragraph_format.space_before = Pt(6)
                para.paragraph_format.space_after = Pt(6)
                # Add a simple text representation instead of border
                para.add_run("‚îÄ" * 50)
                i += 1
                continue
            
            # Handle blockquotes (improved detection)
            elif line.startswith('>'):
                text = line[1:].strip()
                text = _clean_text_for_word(text)
                para = doc.add_paragraph(text)
                para.paragraph_format.left_indent = Inches(0.5)
                para.paragraph_format.right_indent = Inches(0.2)
                for run in para.runs:
                    run.font.italic = True
                    run.font.size = Pt(11)
            
            # Handle table detection (much improved)
            elif '|' in line and line.count('|') >= 2 and not in_table:
                # Start of table
                in_table = True
                table_rows = [line]
                # Look ahead for more table rows
                j = i + 1
                while j < len(lines) and ('|' in lines[j] or lines[j].strip() == ''):
                    if lines[j].strip():
                        table_rows.append(lines[j])
                    j += 1
                
                # Process the complete table
                if len(table_rows) > 1:
                    _add_enhanced_table_to_doc(doc, table_rows)
                
                # Skip the processed lines
                i = j - 1
                in_table = False
                table_rows = []
            
            # Handle bullet points (improved)
            elif line.startswith(('- ', '* ')):
                text = line[2:].strip()
                text = _clean_text_for_word(text)
                para = doc.add_paragraph(text, style='List Bullet')
                para.paragraph_format.space_after = Pt(3)
            
            # Handle numbered lists (improved)
            elif any(line.startswith(f'{num}. ') for num in range(1, 50)):
                # Find the number and extract text
                for num in range(1, 50):
                    if line.startswith(f'{num}. '):
                        text = line[len(f'{num}. '):].strip()
                        text = _clean_text_for_word(text)
                        para = doc.add_paragraph(text, style='List Number')
                        para.paragraph_format.space_after = Pt(3)
                        break
            
            # Handle checkboxes
            elif line.startswith(('- [ ]', '- [x]', '- [X]')):
                checked = '[x]' in line.lower()
                if line.startswith('- [ ]'):
                    text = line[5:].strip()
                else:
                    text = line[5:].strip()
                text = _clean_text_for_word(text)
                symbol = '‚òë' if checked else '‚òê'
                para = doc.add_paragraph(f"{symbol} {text}")
                para.paragraph_format.space_after = Pt(3)
            
            # Regular paragraph (improved)
            else:
                if line.strip():
                    text = _clean_text_for_word(line)
                    if text:
                        para = doc.add_paragraph(text)
                        para.paragraph_format.space_after = Pt(6)
                        para.paragraph_format.line_spacing = 1.15
            
            i += 1
        
        # Save to BytesIO
        doc_buffer = io.BytesIO()
        doc.save(doc_buffer)
        doc_buffer.seek(0)
        return doc_buffer
        
    except Exception as e:
        # Log the error and raise a more informative exception
        error_msg = f"DOCX export error: {str(e)}"
        if "docx" in str(e).lower():
            error_msg += "\n\nDOCX export requires python-docx package. Please install it with: pip install python-docx"
        raise Exception(error_msg) from e

def _clean_markdown_content(content: str) -> str:
    """Pre-clean markdown content for better processing"""
    # Fix common issues
    content = content.replace('\\n', '\n')  # Fix escaped newlines
    content = content.replace('\r\n', '\n')  # Normalize line endings
    
    # Remove excessive empty lines
    lines = content.split('\n')
    cleaned_lines = []
    prev_empty = False
    
    for line in lines:
        is_empty = not line.strip()
        if is_empty and prev_empty:
            continue  # Skip consecutive empty lines
        cleaned_lines.append(line)
        prev_empty = is_empty
    
    return '\n'.join(cleaned_lines)

def _clean_text_for_word(text: str) -> str:
    """Clean text for Word document formatting"""
    if not text:
        return ""
    
    # Remove markdown formatting
    text = text.replace('**', '').replace('*', '').replace('`', '')
    text = text.replace('_', '').replace('~~', '')
    
    # Remove/replace emoji and symbols that don't render well in Word
    emoji_replacements = {
        'üìã': '[Document]',
        'üéØ': '[Target]',
        'üé≠': '[Persona]',
        'üë•': '[Users]',
        'üìä': '[Metrics]',
        'üîß': '[Technical]',
        'üìà': '[Growth]',
        'üìé': '[Attachment]',
        '‚ö°': '[Fast]',
        'üöÄ': '[Launch]',
        '‚úÖ': '[Complete]',
        '‚ùå': '[Not Included]',
        'üî•': '[Priority]',
        'üí°': '[Idea]',
        'üèÜ': '[Success]',
        'üì±': '[Mobile]',
        'üíª': '[Desktop]',
        'üåê': '[Web]',
        'üîí': '[Security]',
        'üîë': '[Key]',
        'üìù': '[Note]'
    }
    
    for emoji, replacement in emoji_replacements.items():
        text = text.replace(emoji, replacement)
    
    # Clean up extra whitespace
    text = ' '.join(text.split())
    
    return text.strip()

def _add_enhanced_table_to_doc(doc, table_rows):
    """Add a professionally formatted table to the document"""
    if len(table_rows) < 2:
        return
    
    # Parse header row more carefully
    header_line = table_rows[0]
    headers = [cell.strip() for cell in header_line.split('|') if cell.strip()]
    
    if not headers:
        return
    
    # Find data rows (skip separator lines)
    data_rows = []
    for i, row in enumerate(table_rows[1:], 1):
        # Skip separator lines (lines with only |, -, spaces, and :)
        if all(c in '|-: ' for c in row.strip()):
            continue
        
        cells = [cell.strip() for cell in row.split('|') if cell.strip() or row.split('|').index(cell) < len(headers)]
        
        # Ensure we have the right number of cells
        while len(cells) < len(headers):
            cells.append('')
        
        # Only add rows with some content
        if any(cell.strip() for cell in cells[:len(headers)]):
            data_rows.append(cells[:len(headers)])
    
    if not data_rows:
        return
    
    # Create table with better styling
    table = doc.add_table(rows=1, cols=len(headers))
    table.style = 'Light List Accent 1'
    
    # Configure table appearance
    table.alignment = WD_ALIGN_PARAGRAPH.LEFT
    
    # Add and format header row
    header_cells = table.rows[0].cells
    for i, header in enumerate(headers):
        if i < len(header_cells):
            clean_header = _clean_text_for_word(header)
            header_cells[i].text = clean_header
            
            # Format header cells
            for paragraph in header_cells[i].paragraphs:
                paragraph.alignment = WD_ALIGN_PARAGRAPH.CENTER
                for run in paragraph.runs:
                    run.font.bold = True
                    run.font.size = Pt(10)
    
    # Add data rows with formatting
    for row_data in data_rows:
        row_cells = table.add_row().cells
        for i, cell_data in enumerate(row_data):
            if i < len(row_cells):
                clean_data = _clean_text_for_word(str(cell_data))
                row_cells[i].text = clean_data
                
                # Format data cells
                for paragraph in row_cells[i].paragraphs:
                    for run in paragraph.runs:
                        run.font.size = Pt(9)
                        
    # Add spacing after table
    doc.add_paragraph()

def _clean_markdown_text(text: str) -> str:
    """Clean markdown formatting from text - legacy function for compatibility"""
    return _clean_text_for_word(text)

def _add_formatted_paragraph(doc, text: str):
    """Add a properly formatted paragraph to the document - legacy function"""
    text = _clean_text_for_word(text)
    if text:
        para = doc.add_paragraph(text)
        para.paragraph_format.space_after = Pt(6)
        para.paragraph_format.line_spacing = 1.15

def _add_table_to_doc(doc, table_rows):
    """Add a table to the document - legacy function, delegates to enhanced version"""
    _add_enhanced_table_to_doc(doc, table_rows)

# Header
st.markdown("""
<div class="main-header">
    <h1>üöÄ BRD Generator</h1>
    <p>Powered by Groq Lightning-Fast AI</p>
    <p>Generate comprehensive Business Requirements Documents in seconds!</p>
</div>
""", unsafe_allow_html=True)

# Sidebar
with st.sidebar:
    st.header("‚öôÔ∏è Configuration")
    
    # Template selection
    templates = st.session_state.template_manager.list_templates()
    # Filter out configuration files from template dropdown
    template_options = {
        tid: tinfo.get('name', tid) 
        for tid, tinfo in templates.items() 
        if tid not in ['template_config'] and not tid.endswith('_config')
    }
    
    selected_template = st.selectbox(
        "üìã Choose Template",
        options=list(template_options.keys()),
        format_func=lambda x: template_options[x],
        index=0
    )
    
    # Document options
    st.header("üìÑ Document Options")
    
    include_appendix = st.checkbox(
        "Include Appendix",
        value=False,
        help="Add CIRCLES analysis, definitions, and methodology details at the end of the document"
    )
    
    if include_appendix:
        st.info("üìã Appendix will include:\n- CIRCLES Framework breakdown\n- Definitions & acronyms\n- Template information")
    else:
        st.info("üìù Document will focus on core business content only")
    
    st.markdown("---")
    
    # API Status
    st.header("üîå API Status")
    if st.session_state.groq_agent:
        st.success("‚úÖ Groq API Connected")
        st.info(f"Model: {st.session_state.groq_agent.model}")
    else:
        st.error("‚ùå Groq API Not Connected")
    
    st.markdown("---")
    
    # Hackathon Info
    st.header("üèÜ Hackathon Version")
    st.info("""
    **Features:**
    - Lightning-fast generation with Groq
    - Full CIRCLES framework (7-step analysis)
    - Professional DOCX export
    - Real-time progress tracking
    - Comprehensive quality evaluation
    
    **CIRCLES Innovation:**
    - Multi-step structured analysis
    - Context-building between steps
    - Detailed insights extraction
    - Complete methodology transparency
    """)

# Main content
col1, col2 = st.columns([2, 1])

with col1:
    st.header("üìù Product Description")
    
    product_idea = st.text_area(
        "Describe your product or project idea:",
        height=200,
        placeholder="""Example: We're building "SupportGenius AI" - an intelligent customer support platform that uses AI to automatically resolve 80% of customer inquiries without human intervention. The platform integrates with existing helpdesk systems and provides instant, accurate responses using natural language processing and machine learning. Our core problem is that customer support teams are overwhelmed with repetitive questions, leading to long wait times and frustrated customers..."""
    )
    
    # Additional context (optional)
    with st.expander("üìä Additional Context (Optional)"):
        st.markdown("Provide additional details to enhance your BRD:")
        
        col_a, col_b = st.columns(2)
        
        with col_a:
            target_audience = st.text_input("üéØ Target Audience")
            business_goals = st.text_area("üíº Business Goals", height=100)
            
        with col_b:
            timeline = st.text_input("‚è∞ Timeline")
            budget_range = st.text_input("üí∞ Budget Range")
        
        technical_requirements = st.text_area("‚öôÔ∏è Technical Requirements", height=100)
        success_metrics = st.text_area("üìà Success Metrics", height=100)
    
    # Generate button
    if st.button("üöÄ Generate BRD with Groq", type="primary", use_container_width=True):
        if not product_idea.strip():
            st.warning("Please provide a product description before generating the BRD.")
        else:
            # Create progress display
            progress_container = st.empty()
            status_container = st.empty()
            
            with st.spinner("Starting CIRCLES Framework Analysis..."):
                # Show CIRCLES steps
                circles_steps = [
                    "üîç Comprehending the Situation",
                    "üë• Identifying the Customer", 
                    "üìù Reporting Customer Needs",
                    "‚úÇÔ∏è Cutting Through Prioritization",
                    "üìã Listing Solutions",
                    "‚öñÔ∏è Evaluating Trade-offs",
                    "üìä Summarizing Recommendations",
                    "üìÑ Generating Final PRD"
                ]
                
                # Create a nice progress display
                progress_container.markdown("""
                **üéØ CIRCLES Framework Progress:**
                
                This generation uses our advanced 7-step CIRCLES methodology for comprehensive business analysis.
                """)
                
                try:
                    # Prepare conversation data
                    conversation_data = {}
                    if target_audience:
                        conversation_data['target_audience'] = target_audience
                    if business_goals:
                        conversation_data['business_goals'] = business_goals
                    if timeline:
                        conversation_data['timeline'] = timeline
                    if budget_range:
                        conversation_data['budget_range'] = budget_range
                    if technical_requirements:
                        conversation_data['technical_requirements'] = technical_requirements
                    if success_metrics:
                        conversation_data['success_metrics'] = success_metrics
                    
                    # Generate PRD with progress updates
                    status_container.info("‚ö° Executing CIRCLES framework with Groq Lightning-Fast AI...")
                    
                    # Generate PRD
                    result = asyncio.run(
                        st.session_state.groq_agent.generate_prd(
                            product_idea=product_idea,
                            template_id=selected_template,
                            conversation_data=conversation_data,
                            session_id=st.session_state.session_id,
                            include_appendix=include_appendix
                        )
                    )
                    
                    st.session_state.generated_prd = result
                    st.session_state.session_id = result.session_id
                    
                    # Clear progress and show success
                    progress_container.empty()
                    status_container.empty()
                    
                    # Show completion with CIRCLES info
                    st.success("‚úÖ BRD generated successfully using CIRCLES framework!")
                    
                    # Show brief summary of what was accomplished
                    if hasattr(result, 'circles_analysis') and result.circles_analysis:
                        circles_responses = result.circles_analysis.get('circles_responses', {})
                        if circles_responses:
                            st.info(f"üéØ Completed all {len(circles_responses)} CIRCLES steps with comprehensive analysis")
                    
                except Exception as e:
                    progress_container.empty()
                    status_container.empty()
                    st.error(f"Error generating BRD: {str(e)}")

with col2:
    st.header("üìä Generation Metrics")
    
    if st.session_state.generated_prd:
        result = st.session_state.generated_prd
        
        # Generation time
        st.markdown("""
        <div class="metric-card">
            <h3>‚ö° Generation Speed</h3>
            <p>Lightning Fast with Groq</p>
        </div>
        """, unsafe_allow_html=True)
        
        # CIRCLES coverage
        circles_analysis = result.circles_analysis
        if circles_analysis:
            overall_coverage = circles_analysis.get('overall_coverage', 0)
            st.markdown(f"""
            <div class="metric-card">
                <h3>üéØ CIRCLES Coverage</h3>
                <p>{overall_coverage:.1f}%</p>
            </div>
            """, unsafe_allow_html=True)
        
        # Document stats
        word_count = len(result.prd_document.split())
        st.markdown(f"""
        <div class="metric-card">
            <h3>üìÑ Document Stats</h3>
            <p>{word_count:,} words</p>
        </div>
        """, unsafe_allow_html=True)
    
    else:
        st.info("üéØ Generate a BRD to see metrics")

# Display generated BRD
if st.session_state.generated_prd:
    st.markdown("---")
    st.header("üìã Generated Business Requirements Document")
    
    # Tabs for different views
    tab1, tab2, tab3, tab4 = st.tabs(["üìÑ Document", "üîç CIRCLES Analysis", "üìä Quality Evaluation", "üì§ Export"])
    
    with tab1:
        st.markdown(st.session_state.generated_prd.prd_document)
    
    with tab2:
        st.subheader("üéØ CIRCLES Framework Analysis")
        
        circles_analysis = st.session_state.generated_prd.circles_analysis
        if circles_analysis:
            
            # Overall coverage with enhanced display
            overall_coverage = circles_analysis.get('overall_coverage', 0)
            quality = circles_analysis.get('analysis_quality', 'Basic')
            framework_executed = circles_analysis.get('circles_framework_executed', False)
            comprehensive = circles_analysis.get('comprehensive_structure', False)
            
            # Enhanced metrics display
            col1, col2, col3 = st.columns(3)
            with col1:
                st.metric("Overall CIRCLES Coverage", f"{overall_coverage:.1f}%")
            with col2:
                st.metric("Analysis Quality", quality)
            with col3:
                st.metric("Framework Executed", "‚úÖ Yes" if framework_executed else "‚ùå No")
            
            # Status indicators
            if framework_executed:
                st.success("üéØ Complete CIRCLES Framework Analysis Executed")
            if comprehensive:
                st.info("üìä Comprehensive PRD Structure Detected")
            
            # Detailed step coverage
            steps_data = circles_analysis.get('steps', {})
            if steps_data:
                st.subheader("üìã CIRCLES Steps Coverage")
                
                for step_key, step_info in steps_data.items():
                    step_name = step_info.get('name', step_key)
                    coverage = step_info.get('coverage_percentage', 0)
                    found_keywords = step_info.get('found_keywords', [])
                    
                    with st.expander(f"{step_name} - {coverage:.1f}% Coverage"):
                        st.progress(coverage / 100)
                        if found_keywords:
                            st.write("**Found Elements:**", ", ".join(found_keywords))
                        else:
                            st.write("*No specific elements detected*")
            
            # Show CIRCLES responses if available
            circles_responses = circles_analysis.get('circles_responses', {})
            if circles_responses:
                st.subheader("ÔøΩ Detailed CIRCLES Analysis")
                
                step_info = {
                    'circles_comprehend_the_situation': {
                        'icon': 'üîç',
                        'title': 'Comprehend the Situation',
                        'description': 'Understanding the broader context and problem space'
                    },
                    'circles_identify_the_customer': {
                        'icon': 'üë•',
                        'title': 'Identify the Customer',
                        'description': 'Defining target users and customer segments'
                    },
                    'circles_report_the_customers_needs': {
                        'icon': 'üìù',
                        'title': 'Report Customer Needs',
                        'description': 'Detailing functional and non-functional requirements'
                    },
                    'circles_cut_through_prioritization': {
                        'icon': '‚úÇÔ∏è',
                        'title': 'Cut Through Prioritization',
                        'description': 'Prioritizing features and requirements'
                    },
                    'circles_list_solutions': {
                        'icon': 'üìã',
                        'title': 'List Solutions',
                        'description': 'Exploring solution alternatives and approaches'
                    },
                    'circles_evaluate_trade_offs': {
                        'icon': '‚öñÔ∏è',
                        'title': 'Evaluate Trade-offs',
                        'description': 'Assessing pros, cons, and implementation considerations'
                    },
                    'circles_summarize_recommendations': {
                        'icon': 'üìä',
                        'title': 'Summarize Recommendations',
                        'description': 'Final recommendations and implementation roadmap'
                    }
                }
                
                for step_key, response in circles_responses.items():
                    if step_key in step_info:
                        info = step_info[step_key]
                        
                        with st.expander(f"{info['icon']} {info['title']}", expanded=False):
                            st.markdown(f"*{info['description']}*")
                            st.markdown("---")
                            st.markdown(response)
            
            # Individual steps coverage (fallback for keyword analysis)
            st.subheader("üìà Framework Coverage Analysis")
            
            step_names = {
                'C1_Comprehend': 'üîç Comprehend the Situation',
                'I_Identify': 'üë• Identify the Customer',
                'R_Report': 'üìù Report Customer Needs',
                'C2_Cut': '‚úÇÔ∏è Cut Through Prioritization',
                'L_List': 'üìã List Solutions',
                'E_Evaluate': '‚öñÔ∏è Evaluate Trade-offs',
                'S_Summarize': 'üìä Summarize Recommendations'
            }
            
            for step_key, step_name in step_names.items():
                if step_key in circles_analysis:
                    step_data = circles_analysis[step_key]
                    coverage = step_data.get('coverage_percentage', 0)
                    is_covered = step_data.get('covered', False)
                    
                    col_a, col_b = st.columns([3, 1])
                    with col_a:
                        st.write(f"{step_name}")
                        if step_data.get('found_keywords'):
                            st.caption(f"Keywords found: {', '.join(step_data['found_keywords'][:3])}")
                    with col_b:
                        color = "green" if is_covered else "red"
                        st.markdown(f"<span style='color: {color}'>{coverage:.0f}%</span>", unsafe_allow_html=True)
                        st.write(f"{step_name}")
                    with col_b:
                        if is_covered:
                            st.success(f"{coverage:.0f}%")
                        else:
                            st.warning("Not covered")
        else:
            st.info("No CIRCLES analysis available")
    
    with tab3:
        st.subheader("üìä Document Quality Evaluation")
        
        # Generate quality evaluation
        if st.button("üîç Analyze Document Quality", type="primary"):
            with st.spinner("Analyzing document quality..."):
                try:
                    evaluator = PRDEvaluator()
                    evaluation = evaluator.evaluate_prd_document(st.session_state.generated_prd.prd_document)
                    st.session_state.quality_evaluation = evaluation
                except Exception as e:
                    st.error(f"Error during evaluation: {e}")
        
        # Display evaluation results
        if hasattr(st.session_state, 'quality_evaluation'):
            eval_data = st.session_state.quality_evaluation
            
            # Overall score
            overall_score = eval_data.get('overall_score', 0)
            st.metric("üìà Overall Quality Score", f"{overall_score:.1f}/100")
            
            # Criteria breakdown
            st.subheader("üìã Quality Criteria Breakdown")
            criteria_scores = eval_data.get('criteria_scores', {})
            
            col1, col2 = st.columns(2)
            with col1:
                for criterion, score in list(criteria_scores.items())[:3]:
                    st.metric(
                        criterion.replace('_', ' ').title(),
                        f"{score:.1f}%",
                        delta=f"{score - 70:.1f}" if score >= 70 else f"{score - 70:.1f}"
                    )
            
            with col2:
                for criterion, score in list(criteria_scores.items())[3:]:
                    st.metric(
                        criterion.replace('_', ' ').title(),
                        f"{score:.1f}%",
                        delta=f"{score - 70:.1f}" if score >= 70 else f"{score - 70:.1f}"
                    )
            
            # Recommendations
            recommendations = eval_data.get('recommendations', [])
            if recommendations:
                st.subheader("üí° Improvement Recommendations")
                for i, rec in enumerate(recommendations, 1):
                    st.write(f"{i}. {rec}")
            
            # Strengths and weaknesses
            col_s, col_w = st.columns(2)
            with col_s:
                strengths = eval_data.get('strengths', [])
                if strengths:
                    st.subheader("‚úÖ Strengths")
                    for strength in strengths:
                        st.success(f"‚Ä¢ {strength}")
            
            with col_w:
                weaknesses = eval_data.get('weaknesses', [])
                if weaknesses:
                    st.subheader("‚ö†Ô∏è Areas for Improvement")
                    for weakness in weaknesses:
                        st.warning(f"‚Ä¢ {weakness}")
        else:
            st.info("Click 'Analyze Document Quality' to see detailed evaluation metrics")
    
    with tab4:
        st.subheader("üì§ Export Options")
        
        col_export1, col_export2 = st.columns(2)
        
        with col_export1:
            st.markdown("#### üìÑ Document Formats")
            
            # Download as markdown
            st.download_button(
                label="üìÑ Download as Markdown",
                data=st.session_state.generated_prd.prd_document,
                file_name=f"BRD_Groq_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md",
                mime="text/markdown",
                use_container_width=True
            )
            
            # Download as DOCX
            try:
                docx_buffer = markdown_to_docx(
                    st.session_state.generated_prd.prd_document,
                    "Business Requirements Document"
                )
                st.download_button(
                    label="üìÑ Download as Word (DOCX)",
                    data=docx_buffer.getvalue(),
                    file_name=f"BRD_Groq_{datetime.now().strftime('%Y%m%d_%H%M%S')}.docx",
                    mime="application/vnd.openxmlformats-officedocument.wordprocessingml.document",
                    use_container_width=True
                )
            except Exception as e:
                st.error(f"DOCX export error: {e}")
                st.info("DOCX export requires python-docx package")
        
        with col_export2:
            st.markdown("#### üìä Analysis & Data")
            
            # Download as JSON (with analysis)
            full_data = {
                "prd_document": st.session_state.generated_prd.prd_document,
                "circles_analysis": st.session_state.generated_prd.circles_analysis,
                "generation_timestamp": st.session_state.generated_prd.generation_timestamp,
                "session_id": st.session_state.generated_prd.session_id,
                "template_used": selected_template,
                "generated_by": "Groq BRD Generator"
            }
            
            # Include quality evaluation if available
            if hasattr(st.session_state, 'quality_evaluation'):
                full_data["quality_evaluation"] = st.session_state.quality_evaluation
            
            st.download_button(
                label="üìä Download Full Analysis (JSON)",
                data=json.dumps(full_data, indent=2),
                file_name=f"BRD_Analysis_Groq_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json",
                mime="application/json",
                use_container_width=True
            )
            
            # Download quality report if available
            if hasattr(st.session_state, 'quality_evaluation'):
                quality_report = f"""# BRD Quality Evaluation Report

**Document:** Business Requirements Document
**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
**Powered by:** Groq BRD Generator

## Overall Score: {st.session_state.quality_evaluation.get('overall_score', 0):.1f}/100

## Criteria Breakdown:
"""
                criteria_scores = st.session_state.quality_evaluation.get('criteria_scores', {})
                for criterion, score in criteria_scores.items():
                    quality_report += f"- **{criterion.replace('_', ' ').title()}:** {score:.1f}%\\n"
                
                quality_report += "\\n## Recommendations:\\n"
                for i, rec in enumerate(st.session_state.quality_evaluation.get('recommendations', []), 1):
                    quality_report += f"{i}. {rec}\\n"
                
                st.download_button(
                    label="üìã Download Quality Report",
                    data=quality_report,
                    file_name=f"BRD_Quality_Report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md",
                    mime="text/markdown",
                    use_container_width=True
                )

# Footer
st.markdown("---")
st.markdown("""
<div class="powered-by">
    Powered by <span class="brand">Groq Lightning AI</span> | 
    Built for Hackathon 2025 | 
    CIRCLES Framework Implementation
</div>
""", unsafe_allow_html=True)

# Instructions for setup
with st.expander("üöÄ Setup Instructions for Groq"):
    st.markdown("""
    ### Getting Started with Groq BRD Generator
    
    **1. Get Groq API Key:**
    - Visit [Groq Console](https://console.groq.com/)
    - Create an account and generate an API key
    
    **2. Set Environment Variable:**
    ```bash
    export GROQ_API_KEY="your_api_key_here"
    ```
    
    **3. Install Dependencies:**
    ```bash
    pip install -r requirements_groq.txt
    ```
    
    **4. Run the Application:**
    ```bash
    streamlit run streamlit_app_groq.py
    ```
    
    **Features:**
    - ‚ö° Lightning-fast generation with Groq
    - üéØ CIRCLES framework implementation
    - üìã Professional BRD formatting
    - üìä Real-time analysis
    - üì§ Multiple export formats
    """)
